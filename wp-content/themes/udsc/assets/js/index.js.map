{"version":3,"file":"index.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,wBAAwB;AACxB;AACA;AACA,4BAA4B;AAC5B;AACA,yBAAyB;AACzB;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,wCAAwC,+BAA+B;AACvE;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB,SAAS;AACT,0CAA0C,gCAAgC;AAC1E,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,2BAA2B;AAC3B,SAAS;AACT,0CAA0C,gCAAgC;AAC1E,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,6BAA6B;AACjG;AACA,oDAAoD,YAAY;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,4BAA4B;AAC5B,SAAS;AACT,0CAA0C,gCAAgC;AAC1E,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,kCAAkC;AACvG;AACA,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kCAAkC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC,OAAO;;AAER;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH;;AAEvH;AACA;AACA;AACA,OAAO,IAAI,GAAG;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2DAA2D;;AAE3D;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA,MAAM;AACN,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA,oEAAoE;AACpE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA,yBAAyB,qCAAqC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mDAAmD;AAC7F;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yCAAyC,kDAAkD;AAC3F;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4CAA4C;AAC5C;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,0DAA0D;AAC1D,8FAA8F;AAC9F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG,IAAI;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mEAAmE;AACnE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,GAAG;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sDAAsD;AACtD,+BAA+B;AAC/B,4BAA4B;AAC5B,KAAK;AACL;AACA,GAAG,IAAI,GAAG;;AAEV;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,aAAa;AACnF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,uBAAuB;AACvB;AACA;AACA;AACA,OAAO;AACP,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,WAAW;AACX;;AAEA,kHAAkH;;AAElH;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA,mDAAmD;AACnD;AACA;AACA,6CAA6C,KAAK;;AAElD;AACA,sEAAsE;AACtE,SAAS;AACT,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC,GAAG;;AAEJ,4CAA4C;AAC5C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B,kBAAkB;AAC3E,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,mCAAmC,8DAA8D;AACjG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0CAA0C,gCAAgC;AAC1E,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B,8BAA8B;AACvF,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2BAA2B,kBAAkB;AAC/E,iBAAiB;AACjB;AACA;AACA;AACA,4DAA4D;AAC5D,qEAAqE;AACrE,oHAAoH;AACpH;AACA,iBAAiB;AACjB;AACA;AACA,0CAA0C,yCAAyC;AACnF;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,SAAS;AACT,0CAA0C,gCAAgC;AAC1E,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B,8BAA8B;AACvF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C,yBAAyB;AACzB;AACA;AACA;AACA;AACA,oBAAoB;AACpB,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2BAA2B,kBAAkB;AAC/E,iBAAiB;AACjB;AACA,sCAAsC,0CAA0C;AAChF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8BAA8B,iCAAiC;AAC/D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0CAA0C,gCAAgC;AAC1E,KAAK;AACL;;AAEA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B,kBAAkB;AAC3E,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,0BAA0B;AACxF,gDAAgD,YAAY;AAC5D;AACA;AACA,8DAA8D,4BAA4B;AAC1F,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,uCAAuC;AACvC,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,yCAAyC;AACzC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0CAA0C,gCAAgC;AAC1E,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2BAA2B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gIAAgI;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,0BAA0B;AACzF,iDAAiD,YAAY;AAC7D;AACA;AACA,+DAA+D,4BAA4B;AAC3F,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,MAAM;AACvE;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,SAAS;AACT,0CAA0C,gCAAgC;AAC1E,KAAK;AACL;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa,UAAU;AACtC;AACA,yCAAyC;AACzC;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2CAA2C;AAClF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,2BAA2B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA,2EAA2E,SAAS;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kDAAkD,qBAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0CAA0C,gCAAgC;AAC1E;AACA,gEAAgE,uBAAuB,sBAAsB;AAC7G,KAAK;AACL;AACA;AACA,0CAA0C,uBAAuB,sBAAsB;;AAE+U;AACta;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACx3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA,IASMA,uBAAuB;EAC3B,SAAAA,wBAAYC,MAAM,EAAE;IAAAC,eAAA,OAAAF,uBAAA;IAClB,IAAI,CAACG,IAAI,GAAGC,QAAQ,CAACC,cAAc,CAACJ,MAAM,CAAC;IAE3C,IAAI,CAAC,IAAI,CAACE,IAAI,EAAE;IAEhB,IAAI,CAACG,IAAI,CAAC,CAAC;EACb;EAAC,OAAAC,YAAA,CAAAP,uBAAA;IAAAQ,GAAA;IAAAC,KAAA,EAED,SAAAH,IAAIA,CAAA,EAAG;MAAA,IAAAI,KAAA;MACL,IAAI,CAACP,IAAI,CAACQ,gBAAgB,CAAC,QAAQ,EAAE,UAACC,CAAC;QAAA,OAAKF,KAAI,CAACG,YAAY,CAACD,CAAC,CAAC;MAAA,EAAC;IACnE;EAAC;IAAAJ,GAAA;IAAAC,KAAA,EAED,SAAAI,YAAYA,CAACD,CAAC,EAAE;MAAA,IAAAE,MAAA;MACdF,CAAC,CAACG,cAAc,CAAC,CAAC;MAElB,IAAMC,SAAS,GAAG,IAAI,CAACb,IAAI,CAACc,aAAa,CAAC,uBAAuB,CAAC;MAClE,IAAI,CAACD,SAAS,EAAE;MAEhB,IAAME,YAAY,GAAGF,SAAS,CAACG,SAAS;;MAExC;MACAH,SAAS,CAACI,QAAQ,GAAG,IAAI;MACzBJ,SAAS,CAACG,SAAS,GACjB,sWAAsW;;MAExW;MACAE,UAAU,CAAC,YAAM;QACfP,MAAI,CAACQ,WAAW,CAAC,CAAC;QAClBR,MAAI,CAACS,SAAS,CAACP,SAAS,EAAEE,YAAY,CAAC;MACzC,CAAC,EAAE,IAAI,CAAC;IACV;EAAC;IAAAV,GAAA;IAAAC,KAAA,EAED,SAAAa,WAAWA,CAAA,EAAG;MACZE,KAAK,CAAC,oCAAoC,CAAC;IAC7C;EAAC;IAAAhB,GAAA;IAAAC,KAAA,EAED,SAAAc,SAASA,CAACP,SAAS,EAAEE,YAAY,EAAE;MACjCF,SAAS,CAACI,QAAQ,GAAG,KAAK;MAC1BJ,SAAS,CAACG,SAAS,GAAGD,YAAY;MAClC,IAAI,CAACf,IAAI,CAACsB,KAAK,CAAC,CAAC;IACnB;EAAC;AAAA,KAGH;AACArB,QAAQ,CAACO,gBAAgB,CAAC,kBAAkB,EAAE,YAAY;EACxD,IAAMe,iBAAiB,GAAGtB,QAAQ,CAACuB,gBAAgB,CACjD,qCACF,CAAC;EAEDD,iBAAiB,CAACE,OAAO,CAAC,UAACzB,IAAI,EAAK;IAClC,IAAIH,uBAAuB,CAACG,IAAI,CAAC0B,EAAE,CAAC;EACtC,CAAC,CAAC;AACJ,CAAC,CAAC,C;;;;;;UC9DF;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;;;;;;;;;;;ACN+D;AAC5B;;AAEnC;AACAC,6EAAoB,CAAC,CAAC;;AAEtB;AACAC,OAAO,CAACC,GAAG,CAAC,iCAAiC,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,kBAAkB,CAAC,CAAC,CAAC,C","sources":["webpack://underscores/./node_modules/@material-tailwind/html/dist/material-tailwind.esm.js","webpack://underscores/./src/js/consultation-form.js","webpack://underscores/webpack/bootstrap","webpack://underscores/webpack/runtime/compat get default export","webpack://underscores/webpack/runtime/define property getters","webpack://underscores/webpack/runtime/hasOwnProperty shorthand","webpack://underscores/webpack/runtime/make namespace object","webpack://underscores/./src/index.js"],"sourcesContent":["\n/*!\n * Material Tailwind JavaScript/TypeScript Library v3.0.0-beta.7\n * (c) 2025 Material Tailwind - Creative Tim\n * Released under the MIT License.\n * Written in TypeScript, usable in both JavaScript and TypeScript projects.\n */\n\nlet popperLoaded = false; // Singleton flag to track loading state\nlet popperReady = null; // Promise to handle loading Popper.js once\nfunction loadPopperJs() {\n    if (popperLoaded) {\n        return popperReady; // Return the existing Promise if already loading or loaded\n    }\n    popperLoaded = true; // Mark Popper.js as being loaded\n    popperReady = new Promise((resolve, reject) => {\n        if (window.Popper) {\n            resolve(window.Popper); // If already loaded globally, resolve immediately\n            return;\n        }\n        const script = document.createElement('script');\n        script.src = 'https://unpkg.com/@popperjs/core@2';\n        script.defer = true;\n        script.onload = () => {\n            resolve(window.Popper); // Resolve once Popper.js is loaded\n        };\n        script.onerror = () => {\n            reject(new Error('Failed to load Popper.js'));\n        };\n        document.head.appendChild(script);\n    });\n    return popperReady;\n}\n\nconst initializedElements$2 = new WeakSet();\nfunction closeAlert(event) {\n    const button = event.currentTarget; // No need for type assertion; AlertEvent ensures it's an HTMLElement\n    const alert = button.closest('[role=\"alert\"]');\n    if (alert) {\n        alert.remove(); // Remove the alert\n    }\n}\nfunction initAlert() {\n    document.querySelectorAll(\"[data-dismiss='alert']\").forEach((button) => {\n        if (!initializedElements$2.has(button)) {\n            // Cast the listener to ensure compatibility with AlertEvent\n            button.addEventListener(\"click\", closeAlert);\n            initializedElements$2.add(button);\n        }\n    });\n}\n// Auto-initialize on DOMContentLoaded and observe dynamically added elements\nif (typeof window !== \"undefined\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n        initAlert(); // Initialize alerts after DOM is loaded\n        // Observe the DOM for dynamically added alerts\n        const observer = new MutationObserver(() => {\n            initAlert(); // Re-initialize alerts when new elements are added\n        });\n        observer.observe(document.body, { childList: true, subtree: true });\n    });\n}\n\n// Gallery component\nconst initializedElements$1 = new WeakSet();\nfunction changeMainImage(event) {\n    const thumbnail = event.currentTarget;\n    const mainImage = document.querySelector('[data-main-image]');\n    if (mainImage) {\n        // Change the main image's src to the clicked thumbnail's src\n        mainImage.src = thumbnail.src;\n        // Optional: Add an \"active\" class to the clicked thumbnail\n        document.querySelectorAll('[data-thumbnail]').forEach((thumb) => {\n            thumb.classList.remove('active-thumbnail');\n        });\n        thumbnail.classList.add('active-thumbnail');\n    }\n}\nfunction initGallery() {\n    document.querySelectorAll('[data-thumbnail]').forEach((thumbnail) => {\n        if (!initializedElements$1.has(thumbnail)) {\n            thumbnail.addEventListener('click', changeMainImage);\n            initializedElements$1.add(thumbnail);\n        }\n    });\n}\nfunction cleanupGallery() {\n    document.querySelectorAll('[data-thumbnail]').forEach((thumbnail) => {\n        if (initializedElements$1.has(thumbnail)) {\n            thumbnail.removeEventListener('click', changeMainImage);\n            initializedElements$1.delete(thumbnail);\n        }\n    });\n}\n// Auto-initialize on DOMContentLoaded and observe dynamically added elements\nif (typeof window !== \"undefined\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n        initGallery(); // Initialize gallery after DOM is loaded\n        // Observe the DOM for dynamically added thumbnails\n        const observer = new MutationObserver(() => {\n            initGallery(); // Re-initialize gallery when new elements are added\n        });\n        observer.observe(document.body, { childList: true, subtree: true });\n    });\n}\n\n// Collapse Component in TypeScript\n// Track initialized elements\nconst initializedElements = new WeakSet();\n/**\n * Toggles the visibility of a collapsible element.\n * @param event - The click event triggering the toggle.\n */\nfunction toggleCollapse(event) {\n    const button = event.currentTarget;\n    if (!button)\n        return;\n    const collapseID = button.getAttribute(\"data-target\");\n    if (collapseID && collapseID.startsWith(\"#\")) {\n        const collapseElement = document.querySelector(collapseID);\n        const isExpanded = button.getAttribute(\"aria-expanded\") === \"true\";\n        if (collapseElement) {\n            // Toggle max-height for collapsible content\n            collapseElement.style.maxHeight = isExpanded ? \"0\" : `${collapseElement.scrollHeight}px`;\n            // Update aria-expanded attribute\n            button.setAttribute(\"aria-expanded\", `${!isExpanded}`);\n            // Toggle rotate-180 class on the icon\n            const icon = button.querySelector(\"[data-icon]\");\n            if (icon) {\n                icon.classList.toggle(\"rotate-180\", !isExpanded);\n            }\n        }\n    }\n}\n/**\n * Initializes collapsible buttons by attaching event listeners.\n */\nfunction initCollapse() {\n    document.querySelectorAll(\"[data-toggle='collapse']\").forEach((button) => {\n        if (!initializedElements.has(button)) {\n            button.addEventListener(\"click\", toggleCollapse);\n            initializedElements.add(button); // Mark as initialized\n        }\n    });\n}\n// Auto-initialize on DOMContentLoaded and observe dynamically added elements\nif (typeof window !== \"undefined\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n        initCollapse(); // Initialize collapsibles after DOM is loaded\n        // Observe the DOM for dynamically added collapsible elements\n        const observer = new MutationObserver(() => {\n            initCollapse(); // Re-initialize collapsibles when new elements are added\n        });\n        observer.observe(document.body, { childList: true, subtree: true });\n    });\n}\n\n/**\n * Class representing a programmatic Collapse component.\n */\nclass Collapse {\n    /**\n     * Creates an instance of Collapse.\n     * @param button - The button element or its selector controlling the collapsible content.\n     * @param collapseElement - The collapsible content element or its selector.\n     * @param config - Configuration options for the collapse.\n     */\n    constructor(button, collapseElement, config = {}) {\n        this.button = this.resolveElement(button, \"Button element not found\");\n        this.collapseElement = this.resolveElement(collapseElement, \"Collapsible content element not found\");\n        this.config = config;\n        this.init();\n    }\n    /**\n     * Resolves an element from an HTMLElement or selector string.\n     * @param elementOrSelector - HTMLElement or a selector string.\n     * @param errorMessage - Error message if the element is not found.\n     * @returns The resolved HTMLElement.\n     */\n    resolveElement(elementOrSelector, errorMessage) {\n        if (typeof elementOrSelector === \"string\") {\n            const resolvedElement = document.querySelector(elementOrSelector);\n            if (!resolvedElement)\n                throw new Error(errorMessage);\n            return resolvedElement;\n        }\n        else if (elementOrSelector instanceof HTMLElement) {\n            return elementOrSelector;\n        }\n        throw new Error(errorMessage);\n    }\n    /**\n     * Initializes the Collapse component by attaching event listeners.\n     */\n    init() {\n        this.button.addEventListener(\"click\", () => this.toggle());\n    }\n    /**\n     * Toggles the collapsible content visibility.\n     */\n    toggle() {\n        const isExpanded = this.button.getAttribute(\"aria-expanded\") === \"true\";\n        // Toggle max-height\n        this.collapseElement.style.maxHeight = isExpanded ? \"0\" : `${this.collapseElement.scrollHeight}px`;\n        // Update aria-expanded attribute\n        this.button.setAttribute(\"aria-expanded\", `${!isExpanded}`);\n        // Toggle rotate class for icons if specified\n        if (this.config.iconSelector) {\n            const icon = document.querySelector(this.config.iconSelector);\n            if (icon) {\n                icon.classList.toggle(\"rotate-180\", !isExpanded);\n            }\n        }\n    }\n    /**\n     * Expands the collapsible content.\n     */\n    expand() {\n        this.collapseElement.style.maxHeight = `${this.collapseElement.scrollHeight}px`;\n        this.button.setAttribute(\"aria-expanded\", \"true\");\n        // Update icon state\n        if (this.config.iconSelector) {\n            const icon = document.querySelector(this.config.iconSelector);\n            if (icon) {\n                icon.classList.add(\"rotate-180\");\n            }\n        }\n    }\n    /**\n     * Collapses the collapsible content.\n     */\n    collapse() {\n        this.collapseElement.style.maxHeight = \"0\";\n        this.button.setAttribute(\"aria-expanded\", \"false\");\n        // Update icon state\n        if (this.config.iconSelector) {\n            const icon = document.querySelector(this.config.iconSelector);\n            if (icon) {\n                icon.classList.remove(\"rotate-180\");\n            }\n        }\n    }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar top = 'top';\nvar bottom = 'bottom';\nvar right = 'right';\nvar left = 'left';\nvar auto = 'auto';\nvar basePlacements = [top, bottom, right, left];\nvar start = 'start';\nvar end = 'end';\nvar clippingParents = 'clippingParents';\nvar viewport = 'viewport';\nvar popper = 'popper';\nvar reference = 'reference';\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nvar beforeRead = 'beforeRead';\nvar read = 'read';\nvar afterRead = 'afterRead'; // pure-logic modifiers\n\nvar beforeMain = 'beforeMain';\nvar main = 'main';\nvar afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nvar beforeWrite = 'beforeWrite';\nvar write = 'write';\nvar afterWrite = 'afterWrite';\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n\nfunction getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}\n\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n  return node;\n}\n\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\nfunction effect$2(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\nvar applyStyles$1 = {\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect$2,\n  requires: ['computeStyles']\n};\n\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\n\nvar max = Math.max;\nvar min = Math.min;\nvar round = Math.round;\n\nfunction getUAString() {\n  var uaData = navigator.userAgentData;\n  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(function (item) {\n      return item.brand + \"/\" + item.version;\n    }).join(' ');\n  }\n  return navigator.userAgent;\n}\n\nfunction isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  var clientRect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n  var _ref = isElement(element) ? getWindow(element) : window,\n    visualViewport = _ref.visualViewport;\n  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n  var width = clientRect.width / scaleX;\n  var height = clientRect.height / scaleY;\n  return {\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x: x,\n    y: y\n  };\n}\n\n// means it doesn't take into account transforms.\n\nfunction getLayoutRect(element) {\n  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: width,\n    height: height\n  };\n}\n\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    var next = child;\n    do {\n      if (next && parent.isSameNode(next)) {\n        return true;\n      } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n      next = next.parentNode || next.host;\n    } while (next);\n  } // Give up, the result is false\n\n  return false;\n}\n\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}\n\nfunction getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return ((isElement(element) ? element.ownerDocument :\n  // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}\n\nfunction getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n  return (\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot ||\n    // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || (\n    // DOM Element detected\n    isShadowRoot(element) ? element.host : null) ||\n    // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) ||\n  // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\nfunction getContainingBlock(element) {\n  var isFirefox = /firefox/i.test(getUAString());\n  var isIE = /Trident/i.test(getUAString());\n  if (isIE && isHTMLElement(element)) {\n    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n    var elementCss = getComputedStyle(element);\n    if (elementCss.position === 'fixed') {\n      return null;\n    }\n  }\n  var currentNode = getParentNode(element);\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\nfunction getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\nfunction withinMaxClamp(min, value, max) {\n  var v = within(min, value, max);\n  return v > max ? max : v;\n}\n\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}\n\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n\nvar toPaddingObject = function toPaddingObject(padding, state) {\n  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n};\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n  var state = _ref.state,\n    name = _ref.name,\n    options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === 'y' ? top : left;\n  var maxProp = axis === 'y' ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\nfunction effect$1(_ref2) {\n  var state = _ref2.state,\n    options = _ref2.options;\n  var _options$element = options.element,\n    arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n    if (!arrowElement) {\n      return;\n    }\n  }\n  if (!contains(state.elements.popper, arrowElement)) {\n    return;\n  }\n  state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\n\nvar arrow$1 = {\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: effect$1,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n};\n\nfunction getVariation(placement) {\n  return placement.split('-')[1];\n}\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref, win) {\n  var x = _ref.x,\n    y = _ref.y;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: round(x * dpr) / dpr || 0,\n    y: round(y * dpr) / dpr || 0\n  };\n}\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n  var popper = _ref2.popper,\n    popperRect = _ref2.popperRect,\n    placement = _ref2.placement,\n    variation = _ref2.variation,\n    offsets = _ref2.offsets,\n    position = _ref2.position,\n    gpuAcceleration = _ref2.gpuAcceleration,\n    adaptive = _ref2.adaptive,\n    roundOffsets = _ref2.roundOffsets,\n    isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x,\n    x = _offsets$x === void 0 ? 0 : _offsets$x,\n    _offsets$y = offsets.y,\n    y = _offsets$y === void 0 ? 0 : _offsets$y;\n  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n    x: x,\n    y: y\n  }) : {\n    x: x,\n    y: y\n  };\n  x = _ref3.x;\n  y = _ref3.y;\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = top;\n  var win = window;\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n    var heightProp = 'clientHeight';\n    var widthProp = 'clientWidth';\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {\n        heightProp = 'scrollHeight';\n        widthProp = 'scrollWidth';\n      }\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n    offsetParent = offsetParent;\n    if (placement === top || (placement === left || placement === right) && variation === end) {\n      sideY = bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :\n      // $FlowFixMe[prop-missing]\n      offsetParent[heightProp];\n      y -= offsetY - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n    if (placement === left || (placement === top || placement === bottom) && variation === end) {\n      sideX = right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :\n      // $FlowFixMe[prop-missing]\n      offsetParent[widthProp];\n      x -= offsetX - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x: x,\n    y: y\n  }, getWindow(popper)) : {\n    x: x,\n    y: y\n  };\n  x = _ref4.x;\n  y = _ref4.y;\n  if (gpuAcceleration) {\n    var _Object$assign;\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\nfunction computeStyles(_ref5) {\n  var state = _ref5.state,\n    options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n    gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n    _options$adaptive = options.adaptive,\n    adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n    _options$roundOffsets = options.roundOffsets,\n    roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    variation: getVariation(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration,\n    isFixed: state.options.strategy === 'fixed'\n  };\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\nvar computeStyles$1 = {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n};\n\nvar passive = {\n  passive: true\n};\nfunction effect(_ref) {\n  var state = _ref.state,\n    instance = _ref.instance,\n    options = _ref.options;\n  var _options$scroll = options.scroll,\n    scroll = _options$scroll === void 0 ? true : _options$scroll,\n    _options$resize = options.resize,\n    resize = _options$resize === void 0 ? true : _options$resize;\n  var window = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\nvar eventListeners = {\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n};\n\nvar hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash$1[matched];\n  });\n}\n\nvar hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash[matched];\n  });\n}\n\nfunction getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\n\nfunction getViewportRect(element, strategy) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    var layoutViewport = isLayoutViewport();\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width: width,\n    height: height,\n    x: x + getWindowScrollBarX(element),\n    y: y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n  var html = getDocumentElement(element);\n  var winScroll = getWindowScroll(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n  var y = -winScroll.scrollTop;\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle(element),\n    overflow = _getComputedStyle.overflow,\n    overflowX = _getComputedStyle.overflowX,\n    overflowY = _getComputedStyle.overflowY;\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n  return getScrollParent(getParentNode(node));\n}\n\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/\n\nfunction listScrollParents(element, list) {\n  var _element$ownerDocumen;\n  if (list === void 0) {\n    list = [];\n  }\n  var scrollParent = getScrollParent(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList :\n  // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(getParentNode(target)));\n}\n\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  var rect = getBoundingClientRect(element, false, strategy === 'fixed');\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\nfunction getClippingRect(element, boundary, rootBoundary, strategy) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n\nfunction computeOffsets(_ref) {\n  var reference = _ref.reference,\n    element = _ref.element,\n    placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n    }\n  }\n  return offsets;\n}\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options,\n    _options$placement = _options.placement,\n    placement = _options$placement === void 0 ? state.placement : _options$placement,\n    _options$strategy = _options.strategy,\n    strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,\n    _options$boundary = _options.boundary,\n    boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n    _options$rootBoundary = _options.rootBoundary,\n    rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n    _options$elementConte = _options.elementContext,\n    elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n    _options$altBoundary = _options.altBoundary,\n    altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n    _options$padding = _options.padding,\n    padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n  var referenceClientRect = getBoundingClientRect(state.elements.reference);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n  return overflowOffsets;\n}\n\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options,\n    placement = _options.placement,\n    boundary = _options.boundary,\n    rootBoundary = _options.rootBoundary,\n    padding = _options.padding,\n    flipVariations = _options.flipVariations,\n    _options$allowedAutoP = _options.allowedAutoPlacements,\n    allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements$1.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements$1;\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\nfunction flip(_ref) {\n  var state = _ref.state,\n    options = _ref.options,\n    name = _ref.name;\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n  var _options$mainAxis = options.mainAxis,\n    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n    _options$altAxis = options.altAxis,\n    checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n    specifiedFallbackPlacements = options.fallbackPlacements,\n    padding = options.padding,\n    boundary = options.boundary,\n    rootBoundary = options.rootBoundary,\n    altBoundary = options.altBoundary,\n    _options$flipVariatio = options.flipVariations,\n    flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n    allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n    var _basePlacement = getBasePlacement(placement);\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n    checksMap.set(placement, checks);\n  }\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases  research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n      if (_ret === \"break\") break;\n    }\n  }\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\nvar flip$1 = {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n};\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return [top, right, bottom, left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\nfunction hide(_ref) {\n  var state = _ref.state,\n    name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\nvar hide$1 = {\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n};\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n      placement: placement\n    })) : offset,\n    skidding = _ref[0],\n    distance = _ref[1];\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\nfunction offset(_ref2) {\n  var state = _ref2.state,\n    options = _ref2.options,\n    name = _ref2.name;\n  var _options$offset = options.offset,\n    offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n    x = _data$state$placement.x,\n    y = _data$state$placement.y;\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\nvar offset$1 = {\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n};\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n    name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\nvar popperOffsets$1 = {\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n};\n\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n    options = _ref.options,\n    name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n    _options$altAxis = options.altAxis,\n    checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n    boundary = options.boundary,\n    rootBoundary = options.rootBoundary,\n    altBoundary = options.altBoundary,\n    padding = options.padding,\n    _options$tether = options.tether,\n    tether = _options$tether === void 0 ? true : _options$tether,\n    _options$tetherOffset = options.tetherOffset,\n    tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n  if (!popperOffsets) {\n    return;\n  }\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min$1 = offset + overflow[mainSide];\n    var max$1 = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n    var _mainSide = mainAxis === 'x' ? top : left;\n    var _altSide = mainAxis === 'x' ? bottom : right;\n    var _offset = popperOffsets[altAxis];\n    var _len = altAxis === 'y' ? 'height' : 'width';\n    var _min = _offset + overflow[_mainSide];\n    var _max = _offset - overflow[_altSide];\n    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\nvar preventOverflow$1 = {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};\n\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n\nfunction getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect();\n  var scaleX = round(rect.width) / element.offsetWidth || 1;\n  var scaleY = round(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' ||\n    // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\nfunction orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\n\nfunction debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n    return pending;\n  };\n}\n\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}\n\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n  var _generatorOptions = generatorOptions,\n    _generatorOptions$def = _generatorOptions.defaultModifiers,\n    defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n    _generatorOptions$def2 = _generatorOptions.defaultOptions,\n    defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update  it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n        var _state$elements = state.elements,\n          reference = _state$elements.reference,\n          popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n          var _state$orderedModifie = state.orderedModifiers[index],\n            fn = _state$orderedModifie.fn,\n            _state$orderedModifie2 = _state$orderedModifie.options,\n            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n            name = _state$orderedModifie.name;\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update  it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n    if (!areValidElements(reference, popper)) {\n      return instance;\n    }\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref) {\n        var name = _ref.name,\n          _ref$options = _ref.options,\n          options = _ref$options === void 0 ? {} : _ref$options,\n          effect = _ref.effect;\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n          var noopFn = function noopFn() {};\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n    return instance;\n  };\n}\n\nvar defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\nvar createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\nconst initializedDropdowns = new WeakSet(); // Prevent duplicate initialization\nlet activeDropdowns = []; // Track active dropdowns for cleanup\nlet Dropdown$1 = class Dropdown {\n    constructor(dropdownElement) {\n        this.popperInstance = null;\n        this.dropdown = dropdownElement;\n        this.button = this.dropdown.querySelector('[data-toggle=\"dropdown\"],[data-toggle=\"menu\"]');\n        this.menu = this.dropdown.querySelector('[data-role=\"menu\"]');\n        this.placement = this.dropdown.getAttribute(\"data-placement\") || \"bottom-start\";\n        this.init();\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Ensure Popper.js is loaded\n            yield loadPopperJs();\n            // Initialize Popper.js\n            this.popperInstance = createPopper(this.button, this.menu, {\n                placement: this.placement,\n                modifiers: [{ name: \"offset\", options: { offset: [0, 5] } }],\n            });\n            // Add event listeners\n            this.button.addEventListener(\"click\", (e) => {\n                e.stopPropagation();\n                this.toggleDropdown();\n            });\n            document.addEventListener(\"click\", (e) => {\n                if (!this.dropdown.contains(e.target)) {\n                    this.closeDropdown();\n                }\n            });\n            // Track active dropdown for cleanup\n            activeDropdowns.push({ dropdown: this.dropdown, popperInstance: this.popperInstance });\n        });\n    }\n    toggleDropdown() {\n        const isExpanded = this.button.getAttribute(\"aria-expanded\") === \"true\";\n        isExpanded ? this.closeDropdown() : this.openDropdown();\n    }\n    openDropdown() {\n        this.button.setAttribute(\"aria-expanded\", \"true\");\n        this.menu.hidden = false;\n        this.menu.classList.remove(\"hidden\");\n        if (this.popperInstance) {\n            this.popperInstance.update();\n        }\n    }\n    closeDropdown() {\n        this.button.setAttribute(\"aria-expanded\", \"false\");\n        this.menu.hidden = true;\n        this.menu.classList.add(\"hidden\");\n    }\n};\nfunction initDropdowns() {\n    document.querySelectorAll(\".dropdown, .menu\").forEach((dropdownElement) => {\n        if (!initializedDropdowns.has(dropdownElement)) {\n            new Dropdown$1(dropdownElement);\n            initializedDropdowns.add(dropdownElement);\n        }\n    });\n}\n// Cleanup function to destroy all active dropdowns\nfunction cleanupDropdowns() {\n    activeDropdowns.forEach(({ dropdown, popperInstance }) => {\n        if (popperInstance)\n            popperInstance.destroy();\n        if (dropdown)\n            initializedDropdowns.delete(dropdown);\n    });\n    activeDropdowns = [];\n}\n// Combined initialization function\nfunction loadAndInitDropdowns() {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield loadPopperJs();\n        initDropdowns();\n    });\n}\n// Auto-initialize Dropdowns in the Browser Environment\nif (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n        loadAndInitDropdowns();\n        // Observe the DOM for dynamically added dropdowns\n        const observer = new MutationObserver(() => {\n            initDropdowns();\n        });\n        observer.observe(document.body, { childList: true, subtree: true });\n    });\n}\n\n/**\n * Class representing a programmatic Dropdown component.\n */\nclass Dropdown {\n    /**\n     * Creates an instance of Dropdown.\n     * @param reference - The element or selector to position the dropdown menu relative to.\n     * @param menu - The menu element to display as the dropdown.\n     * @param config - Configuration options for the dropdown.\n     */\n    constructor(reference, menu, config) {\n        var _a;\n        this.popperInstance = null;\n        this.isOpen = false; // Internal state\n        this.shouldIgnoreClick = false;\n        // Resolve referenceElement and menu\n        this.referenceElement = this.resolveElement(reference, \"Reference element not found\");\n        this.menu = this.resolveElement(menu, \"Menu element not found\");\n        this.config = {\n            placement: config.placement || \"bottom-start\",\n            closeOnOutsideClick: (_a = config.closeOnOutsideClick) !== null && _a !== void 0 ? _a : true,\n            offset: config.offset || [0, 5],\n        };\n        // Bind the document click handler to this instance\n        this.documentClickHandler = this.handleDocumentClick.bind(this);\n        this.init();\n    }\n    /**\n     * Resolves an element from an HTMLElement or selector string.\n     * @param elementOrSelector - HTMLElement or a selector string.\n     * @param errorMessage - Error message if the element is not found.\n     * @returns The resolved HTMLElement.\n     */\n    resolveElement(elementOrSelector, errorMessage) {\n        if (typeof elementOrSelector === \"string\") {\n            const resolvedElement = document.querySelector(elementOrSelector);\n            if (!resolvedElement)\n                throw new Error(errorMessage);\n            return resolvedElement;\n        }\n        else if (elementOrSelector instanceof HTMLElement) {\n            return elementOrSelector;\n        }\n        throw new Error(errorMessage);\n    }\n    /**\n     * Handles document click events for outside clicks\n     */\n    handleDocumentClick(e) {\n        if (this.shouldIgnoreClick) {\n            this.shouldIgnoreClick = false; // Reset flag\n            return;\n        }\n        if (!this.menu.contains(e.target) && !this.referenceElement.contains(e.target)) {\n            this.close();\n        }\n    }\n    /**\n     * Initializes the Dropdown component.\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Load Popper.js dynamically\n            yield loadPopperJs();\n            this.popperInstance = createPopper(this.referenceElement, this.menu, {\n                placement: this.config.placement,\n                modifiers: [{ name: \"offset\", options: { offset: this.config.offset } }],\n            });\n            // Close dropdown if clicked outside\n            if (this.config.closeOnOutsideClick) {\n                document.addEventListener(\"click\", this.documentClickHandler);\n            }\n        });\n    }\n    /**\n     * Set the prevent outside click flag to true.\n     */\n    preventOutsideClick() {\n        this.shouldIgnoreClick = true;\n    }\n    /**\n     * Toggles the dropdown menu visibility.\n     */\n    toggle() {\n        this.isOpen ? this.close() : this.open();\n    }\n    /**\n     * Opens the dropdown menu programmatically.\n     */\n    open() {\n        var _a;\n        if (this.isOpen)\n            return; // Prevent redundant calls\n        this.menu.hidden = false;\n        this.menu.classList.remove(\"hidden\");\n        (_a = this.popperInstance) === null || _a === void 0 ? void 0 : _a.update();\n        this.isOpen = true; // Update internal state\n    }\n    /**\n     * Closes the dropdown menu programmatically.\n     */\n    close() {\n        if (!this.isOpen)\n            return; // Prevent redundant calls\n        this.menu.hidden = true;\n        this.menu.classList.add(\"hidden\");\n        this.isOpen = false; // Update internal state\n    }\n    /**\n     * Destroys the Dropdown instance and cleans up resources.\n     */\n    destroy() {\n        var _a;\n        (_a = this.popperInstance) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.popperInstance = null;\n        document.removeEventListener(\"click\", this.documentClickHandler);\n    }\n}\n\n/**\n * Tracks initialized popover triggers to prevent duplicate initialization.\n */\nconst initializedPopovers = new WeakSet();\n/**\n * Tracks active popovers for cleanup.\n */\nlet activePopovers = [];\n/**\n * Initializes all popovers in the DOM.\n */\nfunction initPopovers() {\n    document.querySelectorAll(\"[data-toggle='popover']\").forEach((trigger) => {\n        var _a;\n        if (initializedPopovers.has(trigger))\n            return; // Skip if already initialized\n        const placement = trigger.getAttribute(\"data-placement\") || \"top\";\n        const popoverClasses = trigger.getAttribute(\"data-popover-class\") || \"popover-default\";\n        const plainContent = trigger.getAttribute(\"data-popover-content\");\n        const isOpenByDefault = trigger.hasAttribute(\"data-open\");\n        let popoverInstance = null;\n        let popperInstance = null;\n        let popoverElement = null;\n        let originalContentElement = null;\n        // Find content element next to the trigger\n        const contentElement = ((_a = trigger.nextElementSibling) === null || _a === void 0 ? void 0 : _a.matches(\"[data-popover-content]\"))\n            ? trigger.nextElementSibling\n            : null;\n        /**\n         * Opens the popover.\n         */\n        function openPopover() {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield loadPopperJs();\n                // Create the popover element\n                popoverElement = document.createElement(\"div\");\n                popoverElement.className = popoverClasses;\n                // Use custom HTML content or plain text\n                if (contentElement) {\n                    originalContentElement = contentElement.cloneNode(true);\n                    originalContentElement.classList.remove(\"hidden\");\n                    popoverElement.appendChild(originalContentElement);\n                }\n                else if (plainContent) {\n                    popoverElement.textContent = plainContent;\n                }\n                else {\n                    console.error(\"No content provided for popover:\", trigger);\n                    return;\n                }\n                // Append the popover element to the body\n                document.body.appendChild(popoverElement);\n                // Initialize Popper.js\n                popoverInstance = createPopper(trigger, popoverElement, {\n                    placement: placement,\n                    modifiers: [{ name: \"offset\", options: { offset: [0, 8] } }],\n                });\n                // Add a small delay to ensure Popper.js calculations are correct\n                requestAnimationFrame(() => {\n                    if (popoverElement) {\n                        popoverElement.style.opacity = \"1\"; // Make the popover visible\n                        popoverElement.style.transform = \"scale(1)\"; // Apply scaling animation\n                        popoverInstance === null || popoverInstance === void 0 ? void 0 : popoverInstance.update(); // Ensure Popper.js recalculates position\n                    }\n                });\n                // Track active popovers for cleanup\n                if (popoverInstance) {\n                    activePopovers.push({ trigger, popoverElement, popperInstance });\n                }\n            });\n        }\n        /**\n         * Closes the popover.\n         */\n        function closePopover() {\n            if (popoverInstance) {\n                popoverInstance.destroy();\n                popoverInstance = null;\n            }\n            if (popoverElement) {\n                popoverElement.remove();\n                popoverElement = null;\n            }\n            if (originalContentElement) {\n                originalContentElement.classList.add(\"hidden\");\n            }\n            // Remove from active popovers\n            activePopovers = activePopovers.filter((p) => p.trigger !== trigger);\n        }\n        // Toggle popover on click\n        trigger.addEventListener(\"click\", (event) => {\n            event.stopPropagation();\n            if (popoverInstance) {\n                closePopover();\n            }\n            else {\n                openPopover();\n            }\n        });\n        // Open popover by default if specified\n        if (isOpenByDefault) {\n            openPopover();\n        }\n        // Mark as initialized\n        initializedPopovers.add(trigger);\n    });\n}\n/**\n * Cleans up all active popovers and their event listeners.\n */\nfunction cleanupPopovers() {\n    activePopovers.forEach(({ popoverElement, popperInstance }) => {\n        if (popperInstance)\n            popperInstance.destroy();\n        if (popoverElement)\n            popoverElement.remove();\n    });\n    activePopovers = [];\n}\n/**\n * Loads Popper.js dynamically and initializes popovers.\n */\nfunction loadAndInitPopovers() {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield loadPopperJs();\n        initPopovers();\n    });\n}\n// Auto-initialize Popovers in the Browser Environment\nif (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n        loadAndInitPopovers();\n        // Observe the DOM for dynamically added popovers\n        const observer = new MutationObserver(() => {\n            initPopovers(); // Reinitialize popovers when new elements are added\n        });\n        observer.observe(document.body, { childList: true, subtree: true });\n    });\n}\n\n/**\n * Class representing a programmatic Popover component.\n */\nclass Popover {\n    /**\n     * Creates an instance of Popover.\n     * @param trigger - The element that triggers the popover.\n     * @param config - Configuration options for the popover.\n     */\n    constructor(trigger, config) {\n        this.popperInstance = null;\n        this.popoverElement = null;\n        this.trigger = trigger;\n        this.config = {\n            placement: config.placement || \"top\",\n            popoverClass: config.popoverClass || \"popover-default\",\n            content: config.content || \"\",\n            openByDefault: config.openByDefault || false,\n            offset: config.offset || [0, 8],\n        };\n        this.init();\n    }\n    /**\n     * Initializes the Popover instance.\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.config.openByDefault) {\n                yield this.open();\n            }\n            // Attach click event to toggle popover\n            this.trigger.addEventListener(\"click\", this.handleTriggerClick.bind(this));\n        });\n    }\n    /**\n     * Handles the click event on the trigger element.\n     * @param event - The click event.\n     */\n    handleTriggerClick(event) {\n        event.stopPropagation();\n        this.toggle();\n    }\n    /**\n     * Opens the popover programmatically.\n     */\n    open() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.popoverElement)\n                return; // Prevent duplicate popovers\n            yield loadPopperJs();\n            // Create the popover element\n            this.popoverElement = document.createElement(\"div\");\n            this.popoverElement.className = this.config.popoverClass || \"popover-default\";\n            // Set the content\n            if (typeof this.config.content === \"string\") {\n                this.popoverElement.textContent = this.config.content;\n            }\n            else if (this.config.content instanceof HTMLElement) {\n                this.popoverElement.appendChild(this.config.content);\n            }\n            else {\n                console.error(\"Invalid content provided for popover:\", this.trigger);\n                return;\n            }\n            // Append to the body\n            document.body.appendChild(this.popoverElement);\n            // Initialize Popper.js\n            this.popperInstance = createPopper(this.trigger, this.popoverElement, {\n                placement: this.config.placement,\n                modifiers: [{ name: \"offset\", options: { offset: this.config.offset } }],\n            });\n            // Make visible\n            requestAnimationFrame(() => {\n                var _a;\n                if (this.popoverElement) {\n                    this.popoverElement.style.opacity = \"1\";\n                    this.popoverElement.style.transform = \"scale(1)\";\n                    (_a = this.popperInstance) === null || _a === void 0 ? void 0 : _a.update();\n                }\n            });\n        });\n    }\n    /**\n     * Closes the popover programmatically.\n     */\n    close() {\n        if (!this.popperInstance || !this.popoverElement)\n            return;\n        this.popperInstance.destroy();\n        this.popperInstance = null;\n        this.popoverElement.remove();\n        this.popoverElement = null;\n    }\n    /**\n     * Toggles the popover's visibility programmatically.\n     */\n    toggle() {\n        if (this.popoverElement) {\n            this.close();\n        }\n        else {\n            this.open();\n        }\n    }\n    /**\n     * Destroys the Popover instance and cleans up resources.\n     */\n    destroy() {\n        this.close();\n        this.trigger.removeEventListener(\"click\", this.handleTriggerClick.bind(this));\n    }\n}\n\nconst initializedTooltips = new WeakSet(); // Track initialized tooltips\nlet activeTooltips = []; // Track active tooltips for cleanup\nfunction initTooltips() {\n    document.querySelectorAll(\"[data-toggle='tooltip']\").forEach((trigger) => {\n        var _a;\n        if (initializedTooltips.has(trigger))\n            return; // Skip already initialized tooltips\n        const title = trigger.getAttribute(\"data-title\") || \"\"; // Tooltip text content\n        const placement = trigger.getAttribute(\"data-placement\") || \"top\";\n        const tooltipClasses = trigger.getAttribute(\"data-tooltip-class\") || \"tooltip-default\";\n        let tooltipInstance = null;\n        let tooltipElement = null;\n        let customContentElement = null;\n        // Check for custom HTML content in sibling\n        if ((_a = trigger.nextElementSibling) === null || _a === void 0 ? void 0 : _a.matches(\"[data-tooltip-content]\")) {\n            customContentElement = trigger.nextElementSibling;\n        }\n        // Function to show the tooltip\n        function showTooltip() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (tooltipElement)\n                    return; // Avoid creating multiple tooltips\n                yield loadPopperJs(); // Ensure Popper.js is loaded\n                tooltipElement = document.createElement(\"div\");\n                tooltipElement.className = tooltipClasses;\n                // Add custom HTML or plain text to tooltip\n                if (customContentElement) {\n                    const contentClone = customContentElement.cloneNode(true);\n                    contentClone.classList.remove(\"hidden\");\n                    tooltipElement.appendChild(contentClone);\n                }\n                else if (title) {\n                    tooltipElement.textContent = title;\n                }\n                else {\n                    console.warn(\"No tooltip content provided for:\", trigger);\n                    return;\n                }\n                document.body.appendChild(tooltipElement);\n                tooltipInstance = createPopper(trigger, tooltipElement, {\n                    placement,\n                    modifiers: [{ name: \"offset\", options: { offset: [0, 8] } }],\n                });\n                // Track active tooltip for cleanup\n                activeTooltips.push({ trigger, tooltipElement, tooltipInstance });\n            });\n        }\n        // Function to hide the tooltip\n        function hideTooltip() {\n            if (tooltipInstance) {\n                tooltipInstance.destroy();\n                tooltipInstance = null;\n            }\n            if (tooltipElement) {\n                tooltipElement.remove();\n                tooltipElement = null;\n            }\n            // Remove from active tooltips\n            activeTooltips = activeTooltips.filter((t) => t.trigger !== trigger);\n        }\n        // Event listeners for showing and hiding tooltips\n        trigger.addEventListener(\"mouseenter\", showTooltip);\n        trigger.addEventListener(\"mouseleave\", hideTooltip);\n        // Mark the trigger as initialized\n        initializedTooltips.add(trigger);\n    });\n}\n// Cleanup function to remove all active tooltips\nfunction cleanupTooltips() {\n    activeTooltips.forEach(({ tooltipElement, tooltipInstance }) => {\n        if (tooltipInstance)\n            tooltipInstance.destroy();\n        if (tooltipElement)\n            tooltipElement.remove();\n    });\n    activeTooltips = [];\n}\n// Combined initialization and loading function\nfunction loadAndInitTooltips() {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield loadPopperJs();\n        initTooltips();\n    });\n}\n// Auto-initialize Tooltips in the browser\nif (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n        loadAndInitTooltips();\n        // Observe DOM for dynamically added tooltips\n        const observer = new MutationObserver(() => {\n            initTooltips();\n        });\n        observer.observe(document.body, { childList: true, subtree: true });\n    });\n}\n\nclass Tooltip {\n    constructor(triggerElement, options = {}) {\n        this.tooltipElement = null;\n        this.tooltipInstance = null;\n        this.triggerElement = triggerElement;\n        this.options = {\n            placement: options.placement || \"top\",\n            tooltipClass: options.tooltipClass || \"tooltip-default\",\n            content: options.content || \"\",\n        };\n        this.init();\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield loadPopperJs();\n            this.triggerElement.addEventListener(\"mouseenter\", this.showTooltip.bind(this));\n            this.triggerElement.addEventListener(\"mouseleave\", this.hideTooltip.bind(this));\n        });\n    }\n    showTooltip() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.tooltipElement)\n                return; // Avoid duplicate tooltips\n            this.tooltipElement = document.createElement(\"div\");\n            this.tooltipElement.className = this.options.tooltipClass;\n            if (typeof this.options.content === \"string\") {\n                this.tooltipElement.textContent = this.options.content;\n            }\n            else if (this.options.content instanceof HTMLElement) {\n                const contentClone = this.options.content.cloneNode(true);\n                contentClone.classList.remove(\"hidden\");\n                this.tooltipElement.appendChild(contentClone);\n            }\n            else {\n                console.warn(\"No valid content provided for tooltip.\");\n                return;\n            }\n            document.body.appendChild(this.tooltipElement);\n            this.tooltipInstance = createPopper(this.triggerElement, this.tooltipElement, {\n                placement: this.options.placement,\n                modifiers: [{ name: \"offset\", options: { offset: [0, 8] } }],\n            });\n        });\n    }\n    hideTooltip() {\n        if (this.tooltipInstance) {\n            this.tooltipInstance.destroy();\n            this.tooltipInstance = null;\n        }\n        if (this.tooltipElement) {\n            this.tooltipElement.remove();\n            this.tooltipElement = null;\n        }\n    }\n    destroy() {\n        this.triggerElement.removeEventListener(\"mouseenter\", this.showTooltip.bind(this));\n        this.triggerElement.removeEventListener(\"mouseleave\", this.hideTooltip.bind(this));\n        this.hideTooltip();\n    }\n}\n\nconst initializedTabs$1 = new WeakSet(); // Track initialized tabs to prevent duplication\n/**\n * Initialize all tabs in the document.\n */\nfunction initTabs() {\n    document.querySelectorAll(\".tab-group\").forEach((tabGroup) => {\n        if (initializedTabs$1.has(tabGroup))\n            return; // Skip already initialized tab groups\n        const tabList = tabGroup.querySelector(\"[role='tablist']\");\n        const tabLinks = (tabList === null || tabList === void 0 ? void 0 : tabList.querySelectorAll(\".tab-link\")) || [];\n        const tabContents = tabGroup.querySelectorAll(\".tab-content\");\n        const indicator = tabList === null || tabList === void 0 ? void 0 : tabList.querySelector(\".tab-indicator\");\n        const isVertical = tabGroup.getAttribute(\"data-orientation\") === \"vertical\";\n        /**\n         * Updates the indicator's position dynamically.\n         * @param link The active tab link element.\n         */\n        function updateIndicator(link) {\n            const rect = link.getBoundingClientRect();\n            const parentRect = tabList === null || tabList === void 0 ? void 0 : tabList.getBoundingClientRect();\n            if (!parentRect || !indicator)\n                return;\n            requestAnimationFrame(() => {\n                if (isVertical) {\n                    indicator.style.transform = `translateY(${rect.top - parentRect.top}px)`;\n                    indicator.style.height = `${rect.height}px`;\n                }\n                else {\n                    indicator.style.transform = `translateX(${rect.left - parentRect.left}px)`;\n                    indicator.style.width = `${rect.width}px`;\n                }\n                // Make the indicator visible\n                indicator.classList.remove(\"hidden\");\n                indicator.style.opacity = \"1\";\n                indicator.style.scale = \"1\";\n            });\n        }\n        /**\n         * Activates the specified tab.\n         * @param link The tab link element to activate.\n         */\n        function activateTab(link) {\n            // Deactivate all tabs and hide their content\n            tabLinks.forEach((item) => item.classList.remove(\"active\"));\n            tabContents.forEach((content) => {\n                content.classList.add(\"hidden\");\n                content.classList.remove(\"block\");\n            });\n            // Activate the clicked tab\n            link.classList.add(\"active\");\n            const targetContentId = link.getAttribute(\"data-tab-target\");\n            const targetContent = targetContentId ? document.getElementById(targetContentId) : null;\n            if (targetContent) {\n                targetContent.classList.add(\"block\");\n                targetContent.classList.remove(\"hidden\");\n            }\n            // Update the indicator position\n            updateIndicator(link);\n        }\n        /**\n         * Initializes the tab group.\n         */\n        function initializeTabGroup() {\n            const activeLink = tabList === null || tabList === void 0 ? void 0 : tabList.querySelector(\".tab-link.active\");\n            if (activeLink) {\n                activateTab(activeLink); // Set indicator for the initially active tab\n            }\n            else if (tabLinks.length > 0) {\n                activateTab(tabLinks[0]); // Fallback to the first tab if no active tab is defined\n            }\n            // Attach click listeners to each tab link\n            tabLinks.forEach((link) => {\n                link.addEventListener(\"click\", (event) => {\n                    event.preventDefault(); // Prevent default browser behavior\n                    activateTab(link); // Activate the clicked tab and update the indicator\n                });\n            });\n        }\n        initializeTabGroup();\n        initializedTabs$1.add(tabGroup); // Mark the tab group as initialized\n    });\n}\n/**\n * Cleans up all initialized tabs.\n */\nfunction cleanupTabs() {\n    // Query all tab groups in the document instead of trying to iterate WeakSet\n    document.querySelectorAll(\".tab-group\").forEach((tabGroup) => {\n        if (initializedTabs$1.has(tabGroup)) {\n            const tabList = tabGroup.querySelector(\"[role='tablist']\");\n            const tabLinks = (tabList === null || tabList === void 0 ? void 0 : tabList.querySelectorAll(\".tab-link\")) || [];\n            // Remove event listeners from tab links\n            tabLinks.forEach((link) => {\n                if (link.parentNode) {\n                    const clone = link.cloneNode(true);\n                    link.parentNode.replaceChild(clone, link);\n                }\n            });\n            // Remove the tab group from the WeakSet\n            initializedTabs$1.delete(tabGroup);\n        }\n    });\n}\n// Auto-initialize tabs in the browser\nif (typeof window !== \"undefined\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n        initTabs();\n        // Observe DOM changes to reinitialize tabs dynamically\n        const observer = new MutationObserver(() => {\n            initTabs();\n        });\n        observer.observe(document.body, { childList: true, subtree: true });\n    });\n}\n\nconst initializedTabs = new WeakSet();\n/**\n * A class for managing tabs programmatically.\n */\nclass Tabs {\n    /**\n     * Creates a new Tabs instance.\n     * @param tabGroup - The container element of the tab group.\n     * @param options - Configuration options for the tabs.\n     */\n    constructor(tabGroup, options = { orientation: \"horizontal\" }) {\n        var _a, _b, _c;\n        if (initializedTabs.has(tabGroup)) {\n            throw new Error(\"This tab group is already initialized.\");\n        }\n        this.tabGroup = tabGroup;\n        this.tabList = tabGroup.querySelector(\"[role='tablist']\");\n        this.tabLinks = Array.from(((_a = this.tabList) === null || _a === void 0 ? void 0 : _a.querySelectorAll(\".tab-link\")) || []);\n        this.tabContents = Array.from(tabGroup.querySelectorAll(\".tab-content\"));\n        this.indicator = ((_b = this.tabList) === null || _b === void 0 ? void 0 : _b.querySelector(\".tab-indicator\")) || null; // Fallback to null if undefined\n        this.orientation = options.orientation || \"horizontal\";\n        this.defaultTabId = options.defaultTabId || ((_c = this.tabLinks[0]) === null || _c === void 0 ? void 0 : _c.id) || \"tab1\";\n        this.initialize();\n        initializedTabs.add(tabGroup);\n    }\n    /**\n     * Initializes the tab group by setting up event listeners and activating the initial tab.\n     */\n    initialize() {\n        var _a;\n        // First check for defaultTabId\n        const defaultTab = this.tabLinks.find(link => link.id === this.defaultTabId);\n        // Then check for an active tab\n        const activeTab = defaultTab ||\n            ((_a = this.tabList) === null || _a === void 0 ? void 0 : _a.querySelector(\".tab-link.active\")) ||\n            this.tabLinks[0];\n        if (activeTab) {\n            // Ensure all other tabs are deactivated first\n            this.tabLinks.forEach((t) => t.classList.remove(\"active\"));\n            this.tabContents.forEach((c) => {\n                c.classList.add(\"hidden\");\n                c.classList.remove(\"block\");\n            });\n            setTimeout(() => {\n                this.activateTab(activeTab.id);\n            }, 300);\n        }\n        this.tabLinks.forEach((link) => {\n            link.addEventListener(\"click\", (event) => {\n                event.preventDefault();\n                this.activateTab(link.id);\n            });\n        });\n    }\n    /**\n     * Updates the position of the tab indicator dynamically.\n     * @param link - The active tab link element.\n     */\n    updateIndicator(link) {\n        var _a;\n        const rect = link.getBoundingClientRect();\n        const parentRect = (_a = this.tabList) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();\n        if (!parentRect || !this.indicator)\n            return;\n        requestAnimationFrame(() => {\n            if (this.orientation === \"vertical\") {\n                this.indicator.style.transform = `translateY(${rect.top - parentRect.top}px)`;\n                this.indicator.style.height = `${rect.height}px`;\n            }\n            else {\n                this.indicator.style.transform = `translateX(${rect.left - parentRect.left}px)`;\n                this.indicator.style.width = `${rect.width}px`;\n            }\n            this.indicator.classList.remove(\"hidden\");\n            this.indicator.style.opacity = \"1\";\n            this.indicator.style.scale = \"1\";\n        });\n    }\n    /**\n     * Activates the specified tab by its ID.\n     * @param tabId - The ID of the tab to activate.\n     */\n    activateTab(tabId) {\n        const tab = this.tabLinks.find((t) => t.id === tabId);\n        const content = this.tabContents.find((c) => c.id === `${tabId}-content`);\n        if (!tab || !content) {\n            console.warn(`Tab or content with id ${tabId} not found`);\n            return;\n        }\n        // Deactivate all tabs and contents\n        this.tabLinks.forEach((t) => t.classList.remove(\"active\"));\n        this.tabContents.forEach((c) => {\n            c.classList.add(\"hidden\");\n            c.classList.remove(\"block\");\n        });\n        // Activate the clicked tab\n        tab.classList.add(\"active\");\n        content.classList.add(\"block\");\n        content.classList.remove(\"hidden\");\n        // Update the indicator position\n        this.updateIndicator(tab);\n    }\n    /**\n     * Cleans up the tab group by removing event listeners and resetting the DOM.\n     */\n    cleanup() {\n        this.tabLinks.forEach((link) => {\n            const clone = link.cloneNode(true);\n            link.replaceWith(clone);\n        });\n        initializedTabs.delete(this.tabGroup);\n    }\n}\n\n// A reference to all initialized triggers, so we don't rebind event listeners.\nlet initializedModals = new WeakSet();\n// Track active modals for cleanup\nlet activeModals = [];\n/**\n * Toggle the modal on or off.\n */\nfunction toggleModal(event) {\n    const trigger = event.currentTarget;\n    if (!trigger)\n        return;\n    const modalID = trigger.getAttribute(\"data-target\");\n    if (!modalID)\n        return;\n    const modal = document.querySelector(modalID);\n    if (!modal)\n        return;\n    const isHidden = modal.classList.contains(\"pointer-events-none\");\n    // Toggle opacity classes\n    modal.classList.toggle(\"opacity-0\", !isHidden);\n    modal.classList.toggle(\"opacity-100\", isHidden);\n    // Toggle pointer-events\n    if (isHidden) {\n        modal.classList.remove(\"pointer-events-none\");\n    }\n    else {\n        setTimeout(() => modal.classList.add(\"pointer-events-none\"), 300);\n    }\n    // Toggle scale classes\n    const modalContent = modal.querySelector(isHidden ? \".scale-95\" : \".scale-100\");\n    if (modalContent) {\n        modalContent.classList.toggle(\"scale-95\", !isHidden);\n        modalContent.classList.toggle(\"scale-100\", isHidden);\n    }\n    // Update aria-hidden\n    modal.setAttribute(\"aria-hidden\", String(!isHidden));\n    // Add or remove event listener for outside clicks\n    if (isHidden) {\n        modal.addEventListener(\"click\", closeOnOutsideClick);\n        activeModals.push(modal);\n    }\n    else {\n        modal.removeEventListener(\"click\", closeOnOutsideClick);\n        activeModals = activeModals.filter((m) => m !== modal);\n    }\n}\n/**\n * Close the modal programmatically or via an event.\n * Accepts either an Event or a direct HTMLElement.\n */\nfunction closeModal(input) {\n    let modal = null;\n    if (input instanceof Event) {\n        const trigger = input.currentTarget;\n        if (!trigger)\n            return;\n        modal = trigger.closest(\".fixed\");\n    }\n    else {\n        modal = input;\n    }\n    if (!modal)\n        return;\n    // Fade out\n    modal.classList.add(\"opacity-0\");\n    modal.classList.remove(\"opacity-100\");\n    // Scale down\n    const modalContent = modal.querySelector(\".scale-100\");\n    if (modalContent) {\n        modalContent.classList.add(\"scale-95\");\n        modalContent.classList.remove(\"scale-100\");\n    }\n    // After transition finishes, hide pointer events\n    setTimeout(() => {\n        modal.classList.add(\"pointer-events-none\");\n        modal.setAttribute(\"aria-hidden\", \"true\");\n    }, 300);\n    modal.removeEventListener(\"click\", closeOnOutsideClick);\n    // Remove from the active modals array\n    activeModals = activeModals.filter((m) => m !== modal);\n}\n/**\n * Close the modal if a click happens outside of the modal content.\n */\nfunction closeOnOutsideClick(event) {\n    const modal = event.currentTarget;\n    if (!modal)\n        return;\n    const modalContent = modal.querySelector(\".scale-100, .scale-95\");\n    if (!modalContent)\n        return;\n    if (!modalContent.contains(event.target)) {\n        closeModal(modal); // Pass the modal directly\n    }\n}\n/**\n * Initialize modal triggers and dismiss buttons.\n */\nfunction initModal() {\n    // For opening modals\n    document.querySelectorAll(\"[data-toggle='modal']\").forEach((trigger) => {\n        if (!initializedModals.has(trigger)) {\n            trigger.addEventListener(\"click\", toggleModal);\n            initializedModals.add(trigger);\n        }\n    });\n    // For closing modals\n    document.querySelectorAll(\"[data-dismiss='modal']\").forEach((button) => {\n        if (!initializedModals.has(button)) {\n            button.addEventListener(\"click\", closeModal);\n            initializedModals.add(button);\n        }\n    });\n}\n/**\n * Cleanup function to remove event listeners from active modals.\n */\nfunction cleanupModals() {\n    activeModals.forEach((modal) => {\n        modal.removeEventListener(\"click\", closeOnOutsideClick);\n    });\n    activeModals = [];\n    // Reassign a new WeakSet to \"clear\" it\n    initializedModals = new WeakSet();\n}\n// Auto-initialize Modals in the Browser Environment\nif (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n        initModal();\n        // Observe the DOM for dynamically added modals\n        const observer = new MutationObserver(() => {\n            initModal(); // Re-initialize modals when new elements are added\n        });\n        observer.observe(document.body, { childList: true, subtree: true });\n    });\n}\n\n/**\n * A class to handle programmatic modal behavior.\n * @implements {IModal}\n */\nclass Modal {\n    /**\n     * Initialize the modal.\n     * @param {HTMLElement} modalElement - The modal element.\n     * @param {ModalConfig} [config={}] - Configuration options for the modal.\n     */\n    constructor(modalElement, config = {}) {\n        this._isVisible = false;\n        /**\n         * Handle keydown events (e.g., Escape to close the modal).\n         * @param {KeyboardEvent} event\n         */\n        this.handleKeydown = (event) => {\n            if (event.key === 'Escape') {\n                this.hide();\n            }\n        };\n        /**\n         * Handle clicks outside the modal content to close the modal.\n         * @param {MouseEvent} event\n         */\n        this.handleOutsideClick = (event) => {\n            const target = event.target;\n            // Reference to the first child of the modal element\n            const modalContent = this._modalElement.firstElementChild;\n            // Check if the click is outside the modal content\n            if (modalContent && !modalContent.contains(target)) {\n                this.hide();\n            }\n        };\n        this._modalElement = modalElement;\n        this._config = Object.assign({ keyboard: true, closeOnOutsideClick: true }, config);\n        // Setup modal\n        this.setupModal();\n        setTimeout(() => {\n            this.removeHiddenClass();\n        }, 300);\n    }\n    /**\n     * Show the modal.\n     */\n    show() {\n        if (this._isVisible)\n            return;\n        this._isVisible = true;\n        this._modalElement.classList.remove('opacity-0', 'pointer-events-none');\n        this._modalElement.classList.add('opacity-100');\n        this._modalElement.setAttribute('aria-hidden', 'false');\n        // Add listeners\n        if (this._config.keyboard) {\n            document.addEventListener('keydown', this.handleKeydown);\n        }\n        if (this._config.closeOnOutsideClick) {\n            document.addEventListener('click', this.handleOutsideClick, true); // Capture phase\n        }\n    }\n    /**\n     * Hide the modal.\n     */\n    hide() {\n        if (!this._isVisible)\n            return;\n        this._isVisible = false;\n        // Hide the modal element with animation\n        this._modalElement.classList.add('opacity-0', 'pointer-events-none');\n        this._modalElement.classList.remove('opacity-100');\n        this._modalElement.setAttribute('aria-hidden', 'true');\n        // Remove listeners\n        if (this._config.keyboard) {\n            document.removeEventListener('keydown', this.handleKeydown);\n        }\n        if (this._config.closeOnOutsideClick) {\n            document.removeEventListener('click', this.handleOutsideClick, true);\n        }\n    }\n    /**\n     * Toggle the modal's visibility.\n     */\n    toggle() {\n        this._isVisible ? this.hide() : this.show();\n    }\n    /**\n     * Check if the modal is currently visible.\n     * @returns {boolean}\n     */\n    isVisible() {\n        return this._isVisible;\n    }\n    /**\n     * Set up initial modal state.\n     * Hides the modal if it's not already hidden.\n     */\n    setupModal() {\n        const isHidden = this._modalElement.classList.contains('opacity-0') ||\n            this._modalElement.getAttribute('aria-hidden') === 'true';\n        this._isVisible = !isHidden;\n        // Ensure proper initial state\n        if (isHidden) {\n            this._modalElement.classList.add('opacity-0', 'pointer-events-none');\n            this._modalElement.classList.remove('opacity-100');\n        }\n        else {\n            this._modalElement.classList.remove('opacity-0', 'pointer-events-none');\n            this._modalElement.classList.add('opacity-100');\n        }\n        this._modalElement.setAttribute('aria-hidden', String(isHidden));\n    }\n    /**\n     * Removes the hidden class from the modal element.\n     * This is typically called before showing the modal.\n     */\n    removeHiddenClass() {\n        this._modalElement.classList.remove('hidden');\n    }\n}\n\n// Accordion Component\nconst initializedAccordionElements = new WeakSet();\n// Helper function to handle icons\nconst handleIcons = (button, isExpanded, isRotating = false) => {\n    const openIcon = button.querySelector(\"[data-accordion-icon-open]\");\n    const closeIcon = button.querySelector(\"[data-accordion-icon-close]\");\n    const rotatingIcon = button.querySelector(\"[data-accordion-icon]\");\n    if (openIcon && closeIcon) {\n        openIcon.style.display = isExpanded ? \"block\" : \"none\";\n        closeIcon.style.display = isExpanded ? \"none\" : \"block\";\n    }\n    if (rotatingIcon) {\n        rotatingIcon.classList.toggle(\"rotate-180\", isRotating ? isExpanded : !isExpanded);\n    }\n};\n// Helper function to toggle accordion state\nconst toggleAccordionState = (targetElement, button, isExpanded) => {\n    targetElement.style.maxHeight = isExpanded ? `${targetElement.scrollHeight}px` : \"0\";\n    button.setAttribute(\"aria-expanded\", String(isExpanded));\n    handleIcons(button, isExpanded);\n};\n// Function to toggle accordion items\nfunction toggleAccordion(event) {\n    const button = event.currentTarget;\n    if (button.getAttribute(\"aria-disabled\") === \"true\")\n        return;\n    const targetID = button.dataset.accordionTarget;\n    const parentElement = button.closest(\"[data-accordion-container]\");\n    const mode = parentElement === null || parentElement === void 0 ? void 0 : parentElement.dataset.accordionMode;\n    if (targetID === null || targetID === void 0 ? void 0 : targetID.startsWith(\"#\")) {\n        const targetElement = document.querySelector(targetID);\n        const isExpanded = button.getAttribute(\"aria-expanded\") === \"true\";\n        if (mode === \"exclusive\" && parentElement) {\n            parentElement.querySelectorAll(\"[data-accordion-toggle]\").forEach(otherButton => {\n                const otherTargetID = otherButton.dataset.accordionTarget;\n                if (otherTargetID && otherTargetID !== targetID) {\n                    const otherElement = document.querySelector(otherTargetID);\n                    if (otherElement instanceof HTMLElement) {\n                        toggleAccordionState(otherElement, otherButton, false);\n                    }\n                }\n            });\n        }\n        if (targetElement) {\n            toggleAccordionState(targetElement, button, !isExpanded);\n        }\n    }\n}\n// Function to manually toggle accordion item by ID\nfunction toggleAccordionById(targetId) {\n    targetId = targetId.startsWith(\"#\") ? targetId : `#${targetId}`;\n    const targetElement = document.querySelector(targetId);\n    const toggleButton = document.querySelector(`[data-accordion-target=\"${targetId}\"]`);\n    if ((toggleButton === null || toggleButton === void 0 ? void 0 : toggleButton.getAttribute(\"aria-disabled\")) === \"true\" ||\n        !targetElement ||\n        !toggleButton)\n        return;\n    const isExpanded = toggleButton.getAttribute(\"aria-expanded\") === \"true\";\n    const parentElement = toggleButton.closest(\"[data-accordion-container]\");\n    const mode = parentElement === null || parentElement === void 0 ? void 0 : parentElement.dataset.accordionMode;\n    if (mode === \"exclusive\" && parentElement) {\n        parentElement.querySelectorAll(\"[data-accordion-toggle]\").forEach((otherButton) => {\n            const otherTargetID = otherButton.dataset.accordionTarget;\n            // Ensure otherTargetID is a string\n            if (typeof otherTargetID === \"string\" && otherTargetID !== targetId) {\n                const otherElement = document.querySelector(otherTargetID);\n                // Ensure otherElement is an instance of HTMLElement\n                if (otherElement instanceof HTMLElement) {\n                    toggleAccordionState(otherElement, otherButton, false);\n                }\n            }\n        });\n    }\n    toggleAccordionState(targetElement, toggleButton, !isExpanded);\n}\n// Function to initialize accordion functionality\nfunction initAccordion() {\n    document.querySelectorAll(\"[data-accordion-toggle]\").forEach((button) => {\n        if (!initializedAccordionElements.has(button)) {\n            button.addEventListener(\"click\", toggleAccordion);\n            initializedAccordionElements.add(button);\n            const targetID = button.dataset.accordionTarget;\n            // Ensure targetID is a valid string\n            if (typeof targetID === \"string\") {\n                const targetElement = document.querySelector(targetID);\n                // Ensure targetElement is an HTMLElement\n                if (targetElement instanceof HTMLElement) {\n                    const isExpanded = button.getAttribute(\"aria-expanded\") === \"true\";\n                    toggleAccordionState(targetElement, button, isExpanded);\n                }\n            }\n        }\n    });\n}\n// Function to cleanup accordion functionality\nfunction cleanupAccordions() {\n    document.querySelectorAll(\"[data-accordion-toggle]\").forEach(button => {\n        if (initializedAccordionElements.has(button)) {\n            button.removeEventListener(\"click\", toggleAccordion);\n            initializedAccordionElements.delete(button);\n        }\n    });\n}\n// Make toggleAccordionById available globally\nif (typeof window !== \"undefined\") {\n    window.toggleAccordionById = toggleAccordionById;\n    document.addEventListener(\"DOMContentLoaded\", () => {\n        initAccordion();\n        new MutationObserver(initAccordion).observe(document.body, {\n            childList: true,\n            subtree: true,\n        });\n    });\n}\n\nclass Accordion {\n    constructor(container, options = {}) {\n        this.initialized = new WeakSet();\n        this.toggleHandler = (event) => {\n            const button = event.currentTarget;\n            this.toggle(button);\n        };\n        this.container = container;\n        this.options = options;\n        this.init();\n    }\n    init() {\n        const buttons = Array.from(this.container.children).filter((el) => el instanceof HTMLElement);\n        buttons.forEach((button) => {\n            const content = button.nextElementSibling;\n            if (content) {\n                this.initialized.add(button);\n                button.addEventListener('click', this.toggleHandler);\n                const isExpanded = this.options.allOpen || false;\n                this.setAccordionState(button, content, isExpanded);\n            }\n        });\n        if (this.options.allOpen) {\n            this.showAll();\n        }\n    }\n    resolveElement(element) {\n        if (typeof element === 'string') {\n            return document.getElementById(element);\n        }\n        return element;\n    }\n    toggle(element) {\n        const button = this.resolveElement(element);\n        if (!button)\n            return;\n        const content = button.nextElementSibling;\n        if (!content)\n            return;\n        const isExpanded = button.getAttribute('aria-expanded') === 'true';\n        if (this.options.exclusive) {\n            Array.from(this.container.children).forEach((child) => {\n                if (child instanceof HTMLElement && child !== button) {\n                    const otherContent = child.nextElementSibling;\n                    if (otherContent) {\n                        this.setAccordionState(child, otherContent, false);\n                    }\n                }\n            });\n        }\n        this.setAccordionState(button, content, !isExpanded);\n    }\n    show(element) {\n        const button = this.resolveElement(element);\n        if (!button)\n            return;\n        const content = button.nextElementSibling;\n        if (!content)\n            return;\n        this.setAccordionState(button, content, true);\n    }\n    hide(element) {\n        const button = this.resolveElement(element);\n        if (!button)\n            return;\n        const content = button.nextElementSibling;\n        if (!content)\n            return;\n        this.setAccordionState(button, content, false);\n    }\n    showAll() {\n        Array.from(this.container.children).forEach((child) => {\n            if (child instanceof HTMLElement) {\n                const content = child.nextElementSibling;\n                if (content) {\n                    this.setAccordionState(child, content, true);\n                }\n            }\n        });\n    }\n    hideAll() {\n        Array.from(this.container.children).forEach((child) => {\n            if (child instanceof HTMLElement) {\n                const content = child.nextElementSibling;\n                if (content) {\n                    this.setAccordionState(child, content, false);\n                }\n            }\n        });\n    }\n    cleanup() {\n        Array.from(this.container.children).forEach((button) => {\n            if (button instanceof HTMLElement && this.initialized.has(button)) {\n                button.removeEventListener('click', this.toggleHandler);\n                this.initialized.delete(button);\n            }\n        });\n    }\n    setAccordionState(button, content, isExpanded) {\n        content.style.maxHeight = isExpanded ? `${content.scrollHeight}px` : '0';\n        button.setAttribute('aria-expanded', String(isExpanded));\n        const openIcon = button.querySelector('[data-accordion-icon-open]');\n        const closeIcon = button.querySelector('[data-accordion-icon-close]');\n        if (openIcon) {\n            openIcon.style.display = isExpanded ? 'block' : 'none';\n        }\n        if (closeIcon) {\n            closeIcon.style.display = isExpanded ? 'none' : 'block';\n        }\n        const icon = button.querySelector('[data-accordion-icon]');\n        if (icon) {\n            icon.classList.toggle('rotate-180', isExpanded);\n        }\n    }\n}\n\n// Stepper Component\nconst initializedStepperElements = new WeakSet();\nfunction updateStepperState(container) {\n    const steps = container.querySelectorAll(\"[data-step]\");\n    const stepContents = container.querySelectorAll(\"[data-step-content]\");\n    const prevButtons = container.querySelectorAll(\"[data-stepper-prev]\");\n    const nextButtons = container.querySelectorAll(\"[data-stepper-next]\");\n    let currentStep = parseInt(container.getAttribute(\"data-step\") || \"1\", 10);\n    function updateState() {\n        // Update step circles and connector lines\n        steps.forEach((step, index) => {\n            const stepNumber = index + 1;\n            step.setAttribute(\"data-active\", String(stepNumber === currentStep));\n            step.setAttribute(\"data-completed\", String(stepNumber < currentStep));\n            step.setAttribute(\"aria-disabled\", String(stepNumber > currentStep));\n        });\n        // Update step content visibility\n        stepContents.forEach((content) => {\n            const contentStep = parseInt(content.getAttribute(\"data-step-content\") || \"0\", 10);\n            if (contentStep === currentStep) {\n                content.classList.remove(\"hidden\");\n            }\n            else {\n                content.classList.add(\"hidden\");\n            }\n        });\n        // Enable/disable buttons based on step\n        prevButtons.forEach((button) => {\n            button.disabled = currentStep === 1;\n        });\n        nextButtons.forEach((button) => {\n            button.disabled = currentStep === steps.length;\n        });\n    }\n    // Event listeners for buttons\n    function onNextButtonClick() {\n        if (currentStep < steps.length) {\n            currentStep++;\n            container.setAttribute(\"data-step\", String(currentStep));\n            updateState();\n        }\n    }\n    function onPrevButtonClick() {\n        if (currentStep > 1) {\n            currentStep--;\n            container.setAttribute(\"data-step\", String(currentStep));\n            updateState();\n        }\n    }\n    nextButtons.forEach((button) => {\n        button.addEventListener(\"click\", onNextButtonClick);\n    });\n    prevButtons.forEach((button) => {\n        button.addEventListener(\"click\", onPrevButtonClick);\n    });\n    // Store references to cleanup\n    container.__stepperCleanup = () => {\n        nextButtons.forEach((button) => {\n            button.removeEventListener(\"click\", onNextButtonClick);\n        });\n        prevButtons.forEach((button) => {\n            button.removeEventListener(\"click\", onPrevButtonClick);\n        });\n    };\n    // Initialize the state\n    updateState();\n}\n// Function to initialize all steppers\nfunction initStepper() {\n    document.querySelectorAll(\"[data-stepper-container]\").forEach((container) => {\n        if (!initializedStepperElements.has(container)) {\n            initializedStepperElements.add(container);\n            // Set initial step based on attribute\n            const initialStep = parseInt(container.getAttribute(\"data-initial-step\") || \"1\", 10);\n            container.setAttribute(\"data-step\", String(initialStep));\n            updateStepperState(container);\n        }\n    });\n}\n// Cleanup function to remove all steppers\nfunction cleanupSteppers() {\n    document.querySelectorAll(\"[data-stepper-container]\").forEach((container) => {\n        if (container.__stepperCleanup) {\n            container.__stepperCleanup();\n            delete container.__stepperCleanup;\n        }\n        initializedStepperElements.delete(container);\n    });\n}\n// Auto-initialize steppers on DOMContentLoaded and observe dynamically added elements\nif (typeof window !== \"undefined\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n        initStepper();\n        new MutationObserver(initStepper).observe(document.body, {\n            childList: true,\n            subtree: true,\n        });\n    });\n}\n\nclass Stepper {\n    constructor(config) {\n        this.steps = config.stepElements;\n        this.contents = config.contentElements;\n        this.prevButton = config.prevButton;\n        this.nextButton = config.nextButton;\n        this.currentStep = config.initialStep || 1;\n        this.updateState();\n        this.prevButton.addEventListener('click', () => this.prev());\n        this.nextButton.addEventListener('click', () => this.next());\n    }\n    updateState() {\n        this.steps.forEach((step, index) => {\n            const stepNumber = index + 1;\n            step.dataset.active = String(stepNumber === this.currentStep);\n            step.dataset.completed = String(stepNumber < this.currentStep);\n            step.setAttribute('aria-disabled', String(stepNumber > this.currentStep));\n        });\n        this.contents.forEach((content, index) => {\n            content.classList.toggle('hidden', index + 1 !== this.currentStep);\n        });\n        this.prevButton.disabled = this.currentStep === 1;\n        this.nextButton.disabled = this.currentStep === this.steps.length;\n    }\n    next() {\n        if (this.currentStep < this.steps.length) {\n            this.currentStep++;\n            this.updateState();\n        }\n    }\n    prev() {\n        if (this.currentStep > 1) {\n            this.currentStep--;\n            this.updateState();\n        }\n    }\n    goToStep(step) {\n        if (step >= 1 && step <= this.steps.length) {\n            this.currentStep = step;\n            this.updateState();\n        }\n    }\n    getCurrentStep() {\n        return this.currentStep;\n    }\n    destroy() {\n        this.prevButton.removeEventListener('click', () => this.prev());\n        this.nextButton.removeEventListener('click', () => this.next());\n    }\n}\n\n// Utilities\n// Aggregate all exports into a single object for UMD consumers\nconst MaterialTailwind = {\n    initAlert,\n    initCollapse,\n    initDropdowns,\n    cleanupDropdowns,\n    initPopovers,\n    cleanupPopovers,\n    initTooltips,\n    cleanupTooltips,\n    initTabs,\n    cleanupTabs,\n    initModal,\n    cleanupModals,\n    initAccordion,\n    cleanupAccordions,\n    toggleAccordionById,\n    initStepper,\n    cleanupSteppers,\n    initGallery,\n    cleanupGallery,\n};\n// Global initialization function\nfunction initMaterialTailwind() {\n    // Initialize non-Popper components\n    initAlert();\n    initCollapse();\n    initTabs();\n    initModal();\n    initAccordion();\n    initStepper();\n    initGallery();\n    // Dynamically load Popper.js and initialize Popper-dependent components\n    loadPopperJs()\n        .then(() => {\n        initDropdowns();\n        initPopovers();\n        initTooltips();\n    })\n        .catch((error) => {\n        console.error('Failed to load Popper.js:', error);\n    });\n}\n// Automatically initialize in the browser environment\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n    document.addEventListener('DOMContentLoaded', () => {\n        // Initialize all components\n        initMaterialTailwind();\n        // Observe DOM changes for dynamically added elements\n        const observer = new MutationObserver(() => {\n            initAlert();\n            initCollapse();\n            initAccordion();\n            initStepper();\n            initGallery();\n            initTabs();\n            initModal();\n            initDropdowns();\n            initPopovers();\n            initTooltips();\n        });\n        observer.observe(document.body, { childList: true, subtree: true });\n        // Expose MaterialTailwind globally for UMD usage\n        window.MaterialTailwind = Object.assign(Object.assign({}, MaterialTailwind), { initMaterialTailwind });\n    });\n}\n// Default export for ES modules\nvar index = Object.assign(Object.assign({}, MaterialTailwind), { initMaterialTailwind });\n\nexport { Accordion, Collapse, Dropdown, MaterialTailwind, Modal, Popover, Stepper, Tabs, Tooltip, cleanupAccordions, cleanupDropdowns, cleanupGallery, cleanupModals, cleanupPopovers, cleanupSteppers, cleanupTabs, cleanupTooltips, index as default, initAccordion, initAlert, initCollapse, initDropdowns, initGallery, initMaterialTailwind, initModal, initPopovers, initStepper, initTabs, initTooltips, toggleAccordionById };\n//# sourceMappingURL=material-tailwind.esm.js.map\n","/**\r\n * Consultation Form JavaScript\r\n *\r\n *     \r\n *\r\n * @package udsc\r\n * @since 1.0.0\r\n */\r\n\r\nclass ConsultationFormHandler {\r\n  constructor(formId) {\r\n    this.form = document.getElementById(formId);\r\n\r\n    if (!this.form) return;\r\n\r\n    this.init();\r\n  }\r\n\r\n  init() {\r\n    this.form.addEventListener(\"submit\", (e) => this.handleSubmit(e));\r\n  }\r\n\r\n  handleSubmit(e) {\r\n    e.preventDefault();\r\n\r\n    const submitBtn = this.form.querySelector('button[type=\"submit\"]');\r\n    if (!submitBtn) return;\r\n\r\n    const originalText = submitBtn.innerHTML;\r\n\r\n    //   \r\n    submitBtn.disabled = true;\r\n    submitBtn.innerHTML =\r\n      '<svg class=\"animate-spin w-4 h-4 mr-2\" fill=\"none\" viewBox=\"0 0 24 24\"><circle class=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" stroke-width=\"4\"></circle><path class=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path></svg>...';\r\n\r\n    //   (   AJAX)\r\n    setTimeout(() => {\r\n      this.showSuccess();\r\n      this.resetForm(submitBtn, originalText);\r\n    }, 1500);\r\n  }\r\n\r\n  showSuccess() {\r\n    alert(\"!     .\");\r\n  }\r\n\r\n  resetForm(submitBtn, originalText) {\r\n    submitBtn.disabled = false;\r\n    submitBtn.innerHTML = originalText;\r\n    this.form.reset();\r\n  }\r\n}\r\n\r\n//     \r\ndocument.addEventListener(\"DOMContentLoaded\", function () {\r\n  const consultationForms = document.querySelectorAll(\r\n    'form[id^=\"consultation-modal-form\"]'\r\n  );\r\n\r\n  consultationForms.forEach((form) => {\r\n    new ConsultationFormHandler(form.id);\r\n  });\r\n});\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { initMaterialTailwind } from \"@material-tailwind/html\";\r\nimport \"./js/consultation-form.js\";\r\n\r\n// Initialize all components in your app\r\ninitMaterialTailwind();\r\n\r\n// Test for auto-reload\r\nconsole.log(\"Webpack watch is working! Time:\", new Date().toLocaleTimeString());\r\n"],"names":["ConsultationFormHandler","formId","_classCallCheck","form","document","getElementById","init","_createClass","key","value","_this","addEventListener","e","handleSubmit","_this2","preventDefault","submitBtn","querySelector","originalText","innerHTML","disabled","setTimeout","showSuccess","resetForm","alert","reset","consultationForms","querySelectorAll","forEach","id","initMaterialTailwind","console","log","Date","toLocaleTimeString"],"sourceRoot":""}